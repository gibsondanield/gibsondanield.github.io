<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prime Factorization Grid</title>
    <script>
    /* primality v1.6.1 - inlined to avoid MIME type issues */
    (function(){function a(b,c,d){var e=a.resolve(b);if(null==e){d=d||b,c=c||"root";var f=Error('Failed to require "'+d+'" from "'+c+'"');throw f.path=d,f.parent=c,f.require=!0,f}var g=a.modules[e];if(!g._resolving&&!g.exports){var h={};h.exports={},h.client=h.component=!0,g._resolving=!0,g.call(this,h.exports,a.relative(e),h),delete g._resolving,g.exports=h.exports}return g.exports}a.modules={},a.aliases={},a.resolve=function(b){"/"===b.charAt(0)&&(b=b.slice(1));for(var c=[b,b+".js",b+".json",b+"/index.js",b+"/index.json"],d=0;d<c.length;d++){var b=c[d];if(a.modules.hasOwnProperty(b))return b;if(a.aliases.hasOwnProperty(b))return a.aliases[b]}},a.normalize=function(a,b){var c=[];if("."!=b.charAt(0))return b;a=a.split("/"),b=b.split("/");for(var d=0;d<b.length;++d)".."==b[d]?a.pop():"."!=b[d]&&""!=b[d]&&c.push(b[d]);return a.concat(c).join("/")},a.register=function(b,c){a.modules[b]=c},a.alias=function(b,c){if(!a.modules.hasOwnProperty(b))throw Error('Failed to alias "'+b+'", it does not exist');a.aliases[c]=b},a.relative=function(b){function c(a,b){for(var c=a.length;c--;)if(a[c]===b)return c;return-1}function d(c){var e=d.resolve(c);return a(e,b,c)}var e=a.normalize(b,"..");return d.resolve=function(d){var f=d.charAt(0);if("/"==f)return d.slice(1);if("."==f)return a.normalize(e,d);var g=b.split("/"),h=c(g,"deps")+1;return h||(h=0),d=g.slice(0,h+1).join("/")+"/deps/"+d},d.exists=function(b){return a.modules.hasOwnProperty(d.resolve(b))},d},a.register("KenanY-factorial/index.js",function(a,b,c){function d(a){return 0===a?1:a*d(a-1)}c.exports=d}),a.register("component-global/index.js",function(a,b,c){c.exports=function(){return this}()}),a.register("KenanY-is-finite/index.js",function(a,b,c){var d=b("global"),e=d.isFinite,f=d.isNaN;c.exports=function(a){return e(a)&&!f(parseFloat(a))}}),a.register("KenanY-is-nan/index.js",function(a,b,c){function d(a){return"number"==typeof a||g.call(a)==e}var e="[object Number]",f=Object.prototype,g=f.toString;c.exports=function(a){return d(a)&&a!=+a}}),a.register("yields-isArray/index.js",function(a,b,c){var d=Array.isArray,e=Object.prototype.toString;c.exports=d||function(a){return!!a&&"[object Array]"==e.call(a)}}),a.register("Nami-Doc-contains/index.js",function(a,b,c){c.exports=function(a,b){if("string"===typeof a)return!!~a.indexOf(b);for(var c=0,d=a.length>>>0;c<d;)if(b===a[c++])return!0;return!1}}),a.register("primality/primality.js",function(a,b,c){function d(a){if(0===a)return 0;if(a%1||a*a<2)return 1;if(0===a%2)return 2;if(0===a%3)return 3;if(0===a%5)return 5;for(var b=Math.sqrt(a),c=7;c<=b;c+=30){if(0===a%c)return c;if(0===a%(c+4))return c+4;if(0===a%(c+6))return c+6;if(0===a%(c+10))return c+10;if(0===a%(c+12))return c+12;if(0===a%(c+16))return c+16;if(0===a%(c+22))return c+22;if(0===a%(c+24))return c+24}return a}function e(a){return m.isNaN(a)||!m.isFinite(a)||a%1||a<2?!1:a!==d(a)?!1:!0}function f(a,b,c){return Math.abs(a-b)!==c?!1:q([a,b])}function g(a,b){return f(a,b,2)}function h(a,b){return f(a,b,4)}function i(a,b){return f(a,b,6)}function j(a){return m.contains(o,a)?!0:0===(l(a-1)+1)%Math.pow(a,2)}function k(a){return m.contains(p,a)?!0:0===(Math.pow(2,a-1)-1)%Math.pow(a,2)}var l=b("factorial"),m={};try{m.contains=b("lodash.contains"),m.isArray=b("lodash.isarray"),m.isFinite=b("lodash.isfinite"),m.isNaN=b("lodash.isnan")}catch(n){m.contains=b("contains"),m.isArray=b("isArray"),m.isFinite=b("is-finite"),m.isNaN=b("is-nan")}var o=[5,13,563],p=[1093,3511],q=function(a){if(null===a||""===a)return null;if(m.isArray(a)){for(var b=a.length;b--;)if(!e(a[b]))return!1;return!0}return e(a)};q.VERSION="1.6.1",q.areTwinPrimes=g,q.areCousinPrimes=h,q.areSexyPrimes=i,q.isWilsonPrime=j,q.isWieferichPrime=k,(c.exports=q).primality=q}),a.alias("KenanY-factorial/index.js","primality/deps/factorial/index.js"),a.alias("KenanY-factorial/index.js","primality/deps/factorial/index.js"),a.alias("KenanY-factorial/index.js","factorial/index.js"),a.alias("KenanY-factorial/index.js","KenanY-factorial/index.js"),a.alias("KenanY-is-finite/index.js","primality/deps/is-finite/index.js"),a.alias("KenanY-is-finite/index.js","is-finite/index.js"),a.alias("component-global/index.js","KenanY-is-finite/deps/global/index.js"),a.alias("KenanY-is-nan/index.js","primality/deps/is-nan/index.js"),a.alias("KenanY-is-nan/index.js","is-nan/index.js"),a.alias("yields-isArray/index.js","primality/deps/isArray/index.js"),a.alias("yields-isArray/index.js","isArray/index.js"),a.alias("Nami-Doc-contains/index.js","primality/deps/contains/index.js"),a.alias("Nami-Doc-contains/index.js","contains/index.js"),a.alias("primality/primality.js","primality/index.js");var b={"boolean":!1,"function":!0,object:!0,number:!1,string:!1,undefined:!1},c=b[typeof window]&&window||this,d=b[typeof exports]&&exports,e=b[typeof module]&&module&&module.exports==d&&module,f=b[typeof global]&&global;!f||f.global!==f&&f.window!==f||(c=f);var g=a("primality");"function"==typeof define&&"object"==typeof define.amd&&define.amd?(c.primality=g,define(function(){return g})):d&&!d.nodeType?e?(e.exports=g).primality=g:d.primality=g:c.primality=g}).call(this);
    </script>
    <style>
        * {
            box-sizing: border-box;
        }
        html, body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            position: fixed;
            width: 100%;
            height: 100%;
        }
        body {
            font-family: Arial, sans-serif;
            background-color: #f0f0f0;
            display: flex;
            flex-direction: column;
        }
        .topbar {
            background-color: #e8e8e8;
            padding: 12px 20px;
            border-bottom: 1px solid #999;
            display: flex;
            align-items: center;
            gap: 25px;
            flex-wrap: wrap;
        }
        .control-section {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .control-section label {
            font-size: 13px;
            font-weight: 500;
            white-space: nowrap;
        }
        .control-section input[type="range"] {
            width: 150px;
            margin: 0 5px;
        }
        .control-section span {
            font-size: 12px;
            color: #666;
            min-width: 40px;
        }
        .radio-group {
            display: flex;
            align-items: center;
            gap: 12px;
            margin: 0;
            padding: 0;
        }
        .radio-item {
            display: flex;
            align-items: center;
            gap: 4px;
        }
        .radio-item input[type="radio"] {
            cursor: pointer;
            margin: 0;
        }
        .radio-item label {
            cursor: pointer;
            font-size: 12px;
            margin: 0;
            display: flex;
            align-items: center;
            gap: 4px;
        }
        .color-swatch {
            width: 12px;
            height: 12px;
            border: 1px solid #333;
            display: inline-block;
        }
        .button {
            padding: 6px 12px;
            font-size: 13px;
            background-color: #d0d0d0;
            border: 1px solid #999;
            cursor: pointer;
            border-radius: 3px;
            white-space: nowrap;
        }
        .button:hover {
            background-color: #c0c0c0;
        }
        .main {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        .coordinates {
            padding: 10px 20px;
            background-color: #ddd;
            font-size: 12px;
            height: auto;
            min-height: 40px;
            font-family: monospace;
        }
        .viewport {
            flex: 1;
            overflow: hidden;
            position: relative;
            background-color: #fff;
            cursor: grab;
            touch-action: none;
            -webkit-overflow-scrolling: touch;
        }
        .viewport.dragging {
            cursor: grabbing;
        }
        .grid-wrapper {
            position: absolute;
            transform-origin: 0 0;
        }
        .grid {
            position: relative;
            width: 100%;
            height: 100%;
        }
        .cell {
            position: absolute;
            border: 1px solid #ddd;
            box-sizing: border-box;
        }
    </style>
</head>
<body>
    <div class="topbar">
        <div class="control-section">
            <label for="rows">Rows on screen:</label>
            <input type="range" id="rows" min="1" max="200" value="30" step="1">
            <span id="rowsValue">30</span>
        </div>
        <fieldset class="control-section radio-group">
            <legend style="font-size: 12px; padding: 0; margin: 0; font-weight: 500;">Composite number color scheme:</legend>
            <div class="radio-item">
                <input type="radio" id="comp-white" name="composite" value="white">
                <label for="comp-white"><span class="color-swatch" style="background-color: rgba(255,255,255,0.5);"></span>White</label>
            </div>
            <div class="radio-item">
                <input type="radio" id="comp-235" name="composite" value="235">
                <label for="comp-235"><span class="color-swatch" style="background-color: rgba(128,128,128,0.5);"></span>2,3,5 RGB</label>
            </div>
            <div class="radio-item">
                <input type="radio" id="comp-modular" name="composite" value="modular" checked>
                <label for="comp-modular"><span class="color-swatch" style="background-color: rgba(200,100,50,0.5);"></span>Modular</label>
            </div>
            <div class="radio-item">
                <input type="radio" id="comp-factorCount" name="composite" value="factorCount">
                <label for="comp-factorCount"><span class="color-swatch" style="background-color: rgba(100,150,200,0.5);"></span>Factor Count</label>
            </div>
            <div class="radio-item">
                <input type="radio" id="comp-lowestFactor" name="composite" value="lowestFactor">
                <label for="comp-lowestFactor"><span class="color-swatch" style="background-color: rgba(150,200,100,0.5);"></span>Lowest</label>
            </div>
            <div class="radio-item">
                <input type="radio" id="comp-highestFactor" name="composite" value="highestFactor">
                <label for="comp-highestFactor"><span class="color-swatch" style="background-color: rgba(200,150,100,0.5);"></span>Highest</label>
            </div>
        </fieldset>
        <fieldset class="control-section radio-group">
            <legend style="font-size: 12px; padding: 0; margin: 0; font-weight: 500;">Special Prime Types:</legend>
            <div class="radio-item">
                <input type="checkbox" id="prime-ramanujan" value="ramanujan">
                <label for="prime-ramanujan" title="Ramanujan primes: The nth Ramanujan prime is the least integer R_n such that π(x) - π(x/2) ≥ n for all x ≥ R_n, where π(x) is the prime counting function"><span class="color-swatch" style="background-color: rgba(139,0,0,1);"></span>Ramanujan</label>
            </div>
            <div class="radio-item">
                <input type="checkbox" id="prime-fermat" value="fermat">
                <label for="prime-fermat" title="Fermat primes: Primes of the form F_n = 2^(2^n) + 1. Only 5 are known: 3, 5, 17, 257, 65537"><span class="color-swatch" style="background-color: rgba(0,0,139,1);"></span>Fermat</label>
            </div>
            <div class="radio-item">
                <input type="checkbox" id="prime-mersenne" value="mersenne">
                <label for="prime-mersenne" title="Mersenne primes: Primes of the form M_p = 2^p - 1 where p is also prime"><span class="color-swatch" style="background-color: rgba(139,69,0,1);"></span>Mersenne</label>
            </div>
            <div class="radio-item">
                <input type="checkbox" id="prime-twin" value="twin">
                <label for="prime-twin" title="Twin primes: Pairs of primes that differ by 2 (e.g., 3 and 5, 11 and 13, 17 and 19)"><span class="color-swatch" style="background-color: rgba(0,100,0,1);"></span>Twin</label>
            </div>
            <div class="radio-item">
                <input type="checkbox" id="prime-cousin" value="cousin">
                <label for="prime-cousin" title="Cousin primes: Pairs of primes that differ by 4 (e.g., 3 and 7, 7 and 11, 13 and 17)"><span class="color-swatch" style="background-color: rgba(139,69,69,1);"></span>Cousin</label>
            </div>
            <div class="radio-item">
                <input type="checkbox" id="prime-sexy" value="sexy">
                <label for="prime-sexy" title="Sexy primes: Pairs of primes that differ by 6 (e.g., 5 and 11, 7 and 13, 23 and 29). Name from Latin 'sex' meaning six"><span class="color-swatch" style="background-color: rgba(75,0,130,1);"></span>Sexy</label>
            </div>
            <div class="radio-item">
                <input type="checkbox" id="prime-sophie" value="sophie">
                <label for="prime-sophie" title="Sophie Germain primes: A prime p where 2p + 1 is also prime (e.g., 2, 3, 5, 11, 23, 29)"><span class="color-swatch" style="background-color: rgba(0,128,128,1);"></span>Sophie Germain</label>
            </div>
            <div class="radio-item">
                <input type="checkbox" id="prime-safe" value="safe">
                <label for="prime-safe" title="Safe primes: A prime p where (p-1)/2 is also prime. The number (p-1)/2 is called a Sophie Germain prime"><span class="color-swatch" style="background-color: rgba(128,0,128,1);"></span>Safe</label>
            </div>
            <div class="radio-item">
                <input type="checkbox" id="prime-palindromic" value="palindromic">
                <label for="prime-palindromic" title="Palindromic primes: Primes that read the same forwards and backwards (e.g., 2, 3, 5, 7, 11, 101, 131)"><span class="color-swatch" style="background-color: rgba(139,90,43,1);"></span>Palindromic</label>
            </div>
            <div class="radio-item">
                <input type="checkbox" id="prime-triplet" value="triplet">
                <label for="prime-triplet" title="Prime triplets: (p, p+2, p+6) or (p, p+4, p+6) where all three are prime (e.g., 5,7,11 or 7,11,13)"><span class="color-swatch" style="background-color: rgba(47,79,79,1);"></span>Triplet</label>
            </div>
            <div class="radio-item">
                <input type="checkbox" id="prime-quadruplet" value="quadruplet">
                <label for="prime-quadruplet" title="Prime quadruplets: (p, p+2, p+6, p+8) where all four are prime (e.g., 5,7,11,13)"><span class="color-swatch" style="background-color: rgba(85,107,47,1);"></span>Quadruplet</label>
            </div>
            <div class="radio-item">
                <input type="checkbox" id="prime-chen" value="chen">
                <label for="prime-chen" title="Chen primes: Prime p where p+2 is either prime or semiprime (product of exactly 2 primes)"><span class="color-swatch" style="background-color: rgba(139,35,69,1);"></span>Chen</label>
            </div>
            <div class="radio-item">
                <input type="checkbox" id="prime-pythagorean" value="pythagorean">
                <label for="prime-pythagorean" title="Pythagorean primes: Primes of the form 4k+1, can be expressed as sum of two squares"><span class="color-swatch" style="background-color: rgba(0,100,100,1);"></span>Pythagorean</label>
            </div>
            <div class="radio-item">
                <input type="checkbox" id="prime-circular" value="circular">
                <label for="prime-circular" title="Circular primes: Primes where every rotation of digits gives another prime (e.g., 13, 197, 199)"><span class="color-swatch" style="background-color: rgba(102,51,153,1);"></span>Circular</label>
            </div>
        </fieldset>
        <button id="recenterBtn" class="button">Recenter</button>
        <button id="resetBtn" class="button">Reset</button>
    </div>
    <div class="main">
        <div class="coordinates" id="coordinates">Hover over cells or scroll to zoom</div>
        <div class="viewport" id="viewport">
            <div class="grid-wrapper" id="gridWrapper">
                <div class="grid" id="grid"></div>
            </div>
        </div>
    </div>

    <script>
        const grid = document.getElementById('grid');
        const gridWrapper = document.getElementById('gridWrapper');
        const viewport = document.getElementById('viewport');
        const coordinatesDisplay = document.getElementById('coordinates');
        const rowsInput = document.getElementById('rows');
        const rowsValueDisplay = document.getElementById('rowsValue');
        const recenterBtn = document.getElementById('recenterBtn');
        const resetBtn = document.getElementById('resetBtn');

        let baseRowsOnScreen = parseInt(rowsInput.value) || 30;
        let rowsOnScreen = baseRowsOnScreen;
        let currentCompositeColorScheme = '235';
        let activePrimeTypes = new Set();
        let cellWidth = 0;
        let cellHeight = 0;
        let columnsOnScreen = 0;
        let animationFrameId = null;
        let flashFrameCount = 0;
        let renderPending = false;

        // Pan and zoom state
        let zoomLevel = 1;
        let offsetX = 0;
        let offsetY = 0;
        let isDragging = false;
        let dragStartX = 0;
        let dragStartY = 0;
        let dragStartOffsetX = 0;
        let dragStartOffsetY = 0;

        // Calculate cell dimensions based on viewport size
        function calculateCellDimensions() {
            const viewportWidth = viewport.clientWidth;
            const viewportHeight = viewport.clientHeight;

            // Square cells: height determines size
            cellHeight = viewportHeight / rowsOnScreen;
            cellWidth = cellHeight;

            // Calculate how many columns fit
            columnsOnScreen = Math.floor(viewportWidth / cellWidth);

            return { cellWidth, cellHeight };
        }

        // Calculate visible grid bounds
        function getVisibleGridBounds() {
            const viewportWidth = viewport.clientWidth;
            const viewportHeight = viewport.clientHeight;

            // Viewport bounds in grid coordinates
            // offsetX positions the grid; negative offset means grid moves right (show columns to left)
            const vpLeft = -offsetX / zoomLevel;
            const vpTop = -offsetY / zoomLevel;
            const vpRight = vpLeft + viewportWidth / zoomLevel;
            const vpBottom = vpTop + viewportHeight / zoomLevel;

            // Convert to grid cell coordinates (can include negative columns)
            // Rows are positioned as (row - 1) * cellHeight, so account for that offset
            // Minimum row is 1 (row 0 is deleted)
            const minCol = Math.floor(vpLeft / cellWidth);
            const maxCol = Math.ceil(vpRight / cellWidth) + 1;
            const minRow = Math.max(1, Math.floor(vpTop / cellHeight) + 1);
            const maxRow = Math.ceil(vpBottom / cellHeight) + 2;

            return { minCol, maxCol, minRow, maxRow };
        }

        // Prevent scrolling above row 1
        function constrainView() {
            // offsetY = 0 means row 1 is at the top. We can't go higher (positive offsetY).
            if (offsetY > 0) offsetY = 0;
        }

        // Update transforms
        function updateTransform() {
            constrainView();
            gridWrapper.style.transform = `translate(${offsetX}px, ${offsetY}px) scale(${zoomLevel})`;
            renderVisibleCells();
        }

        // Recenter button - only center column 0 horizontally
        recenterBtn.addEventListener('click', () => {
            offsetX = viewport.clientWidth / 2;
            updateTransform();
        });

        // Reset button - reset everything
        resetBtn.addEventListener('click', () => {
            zoomLevel = 1;
            offsetX = viewport.clientWidth / 2;
            offsetY = 0;
            baseRowsOnScreen = 30;
            rowsInput.value = 30;
            rowsValueDisplay.textContent = '30';
            rowsOnScreen = baseRowsOnScreen;
            calculateCellDimensions();
            updateTransform();
        });

        // Mouse wheel zoom
        viewport.addEventListener('wheel', (e) => {
            e.preventDefault();
            const oldZoom = zoomLevel;
            const delta = e.deltaY > 0 ? 0.9 : 1.1;
            zoomLevel = Math.max(0.5, Math.min(5, zoomLevel * delta));

            // Update rows on screen based on zoom
            rowsOnScreen = Math.max(1, Math.round(baseRowsOnScreen / zoomLevel));
            rowsInput.value = rowsOnScreen;
            rowsValueDisplay.textContent = rowsOnScreen;

            const rect = viewport.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            offsetX += mouseX * (1 / oldZoom - 1 / zoomLevel);
            offsetY += mouseY * (1 / oldZoom - 1 / zoomLevel);

            updateTransform();
        });

        // Mouse drag
        viewport.addEventListener('mousedown', (e) => {
            isDragging = true;
            dragStartX = e.clientX;
            dragStartY = e.clientY;
            dragStartOffsetX = offsetX;
            dragStartOffsetY = offsetY;
            viewport.classList.add('dragging');
        });

        document.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const deltaX = e.clientX - dragStartX;
                const deltaY = e.clientY - dragStartY;
                offsetX = dragStartOffsetX + deltaX;
                offsetY = dragStartOffsetY + deltaY;

                // Throttle rendering - only schedule one render per frame
                if (!renderPending) {
                    renderPending = true;
                    requestAnimationFrame(() => {
                        constrainView();
                        gridWrapper.style.transform = `translate(${offsetX}px, ${offsetY}px) scale(${zoomLevel})`;
                        renderVisibleCells();
                        renderPending = false;
                    });
                }
            }
        });

        document.addEventListener('mouseup', () => {
            isDragging = false;
            viewport.classList.remove('dragging');
        });

        // Touch events for mobile
        viewport.addEventListener('touchstart', (e) => {
            if (e.touches.length === 1) {
                isDragging = true;
                dragStartX = e.touches[0].clientX;
                dragStartY = e.touches[0].clientY;
                dragStartOffsetX = offsetX;
                dragStartOffsetY = offsetY;
                viewport.classList.add('dragging');
            } else if (e.touches.length === 2) {
                // Pinch zoom - store initial touch distance
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                e.touches[0].initialDistance = Math.sqrt(dx * dx + dy * dy);
            }
            e.preventDefault();
        });

        viewport.addEventListener('touchmove', (e) => {
            if (e.touches.length === 1 && isDragging) {
                const deltaX = e.touches[0].clientX - dragStartX;
                const deltaY = e.touches[0].clientY - dragStartY;
                offsetX = dragStartOffsetX + deltaX;
                offsetY = dragStartOffsetY + deltaY;

                // Throttle rendering - only schedule one render per frame
                if (!renderPending) {
                    renderPending = true;
                    requestAnimationFrame(() => {
                        constrainView();
                        gridWrapper.style.transform = `translate(${offsetX}px, ${offsetY}px) scale(${zoomLevel})`;
                        renderVisibleCells();
                        renderPending = false;
                    });
                }
            } else if (e.touches.length === 2 && e.touches[0].initialDistance) {
                // Pinch zoom
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                const currentDistance = Math.sqrt(dx * dx + dy * dy);
                const oldZoom = zoomLevel;
                const zoomRatio = currentDistance / e.touches[0].initialDistance;
                zoomLevel = Math.max(0.5, Math.min(5, zoomLevel * zoomRatio));

                // Update rows on screen based on zoom
                rowsOnScreen = Math.max(1, Math.round(baseRowsOnScreen / zoomLevel));
                rowsInput.value = rowsOnScreen;
                rowsValueDisplay.textContent = rowsOnScreen;

                // Center zoom on touch point
                const rect = viewport.getBoundingClientRect();
                const centerX = (e.touches[0].clientX + e.touches[1].clientX) / 2 - rect.left;
                const centerY = (e.touches[0].clientY + e.touches[1].clientY) / 2 - rect.top;
                offsetX += centerX * (1 / oldZoom - 1 / zoomLevel);
                offsetY += centerY * (1 / oldZoom - 1 / zoomLevel);

                e.touches[0].initialDistance = currentDistance;
                updateTransform();
            }
            e.preventDefault();
        });

        viewport.addEventListener('touchend', (e) => {
            if (e.touches.length === 0) {
                isDragging = false;
                viewport.classList.remove('dragging');
            }
            if (e.touches.length < 2) {
                delete e.touches[0].initialDistance;
            }
            e.preventDefault();
        });

        // Row control - changes the base rows at zoom 1
        rowsInput.addEventListener('input', () => {
            baseRowsOnScreen = parseInt(rowsInput.value);
            rowsOnScreen = Math.max(1, Math.round(baseRowsOnScreen / zoomLevel));
            rowsValueDisplay.textContent = rowsOnScreen;
            calculateCellDimensions();
            renderVisibleCells();
        });


        // Window resize handler
        window.addEventListener('resize', () => {
            calculateCellDimensions();
            renderVisibleCells();
        });

        // Color functions
        const primeColors = {};
        let primeCounter = 0;
        function getPrimeColorModular(prime) {
            if (!primeColors[prime]) {
                const r = (primeCounter * 37) % 255;
                const g = (primeCounter * 67) % 255;
                const b = (primeCounter * 97) % 255;
                primeColors[prime] = `rgba(${r}, ${g}, ${b}, 0.1)`;
                primeCounter++;
            }
            return primeColors[prime];
        }

        function getPrimeColor235(prime) {
            const r = (prime % 2) !== 0 ? 255 : 0;
            const b = (prime % 3) !== 0 ? 255 : 0;
            const g = (prime % 5) !== 0 ? 255 : 0;
            return `rgba(${r}, ${g}, ${b}, 0.1)`;
        }

        function getColorByFactorCount(num) {
            const factors = primeFactorization(num).length;
            const r = (factors * 30) % 255;
            const g = (factors * 60) % 255;
            const b = (factors * 90) % 255;
            return `rgba(${r}, ${g}, ${b}, 0.1)`;
        }

        function getColorByLowestFactor(num) {
            const factors = primeFactorization(num);
            if (factors.length === 0) return 'rgba(255, 255, 255, 0.1)';
            const lowest = factors[0];
            const r = (lowest * 37) % 255;
            const g = (lowest * 67) % 255;
            const b = (lowest * 97) % 255;
            return `rgba(${r}, ${g}, ${b}, 0.1)`;
        }

        function getColorByHighestFactor(num) {
            const factors = primeFactorization(num);
            if (factors.length === 0) return 'rgba(255, 255, 255, 0.1)';
            const highest = factors[factors.length - 1];
            const r = (highest * 37) % 255;
            const g = (highest * 67) % 255;
            const b = (highest * 97) % 255;
            return `rgba(${r}, ${g}, ${b}, 0.1)`;
        }

        const compositeColorFunctions = {
            'white': () => 'rgba(255, 255, 255, 0.1)',
            '235': getPrimeColor235,
            'modular': getPrimeColorModular,
            'factorCount': getColorByFactorCount,
            'lowestFactor': getColorByLowestFactor,
            'highestFactor': getColorByHighestFactor
        };

        // Ramanujan primes: A000657 in OEIS
        const ramanujanPrimes = [2, 11, 13, 29, 37, 41, 47, 59, 67, 71, 79, 97, 101, 107, 127, 149, 163, 181, 191, 197, 223, 229, 233, 239, 241, 251, 257, 263, 269, 281, 307, 311, 317, 337, 347, 349, 353, 359, 367, 373, 389, 397, 401, 409, 419, 431, 439, 443, 449, 457, 461, 467, 479];

        // Fermat primes: F_n = 2^(2^n) + 1, only known ones
        const fermatPrimes = [3, 5, 17, 257, 65537];

        // Mersenne primes: 2^p - 1 where p is prime
        const mersennePrimes = [3, 7, 31, 127, 8191, 131071, 524287, 2147483647];

        // Sophie Germain primes: p where 2p+1 is also prime
        const sophieGermainPrimes = [2, 3, 5, 11, 23, 29, 41, 53, 83, 89, 113, 131, 173, 179, 191, 197, 227, 233, 239, 251, 281, 293, 359, 419, 431, 443, 491, 509, 593, 641, 653, 659, 743, 761, 809, 827, 857, 881, 929, 953, 1013, 1019, 1031, 1049, 1079, 1103, 1223, 1229, 1289, 1319];

        const primeTypeColors = {
            'ramanujan': 'rgba(139, 0, 0, 1)',        // dark red
            'fermat': 'rgba(0, 0, 139, 1)',            // dark blue
            'mersenne': 'rgba(139, 69, 0, 1)',         // dark orange/brown
            'twin': 'rgba(0, 100, 0, 1)',              // dark green
            'cousin': 'rgba(139, 69, 69, 1)',          // dark pink/rose
            'sexy': 'rgba(75, 0, 130, 1)',             // indigo (darker purple)
            'sophie': 'rgba(0, 128, 128, 1)',          // dark cyan/teal
            'safe': 'rgba(128, 0, 128, 1)',            // dark magenta
            'palindromic': 'rgba(139, 90, 43, 1)',     // dark brown
            'triplet': 'rgba(47, 79, 79, 1)',          // dark slate gray
            'quadruplet': 'rgba(85, 107, 47, 1)',      // dark olive
            'chen': 'rgba(139, 35, 69, 1)',            // dark maroon
            'pythagorean': 'rgba(0, 100, 100, 1)',     // dark teal
            'circular': 'rgba(102, 51, 153, 1)'        // dark purple
        };

        function isRamanujanPrime(n) {
            return ramanujanPrimes.includes(n);
        }

        function isFermatPrime(n) {
            return fermatPrimes.includes(n);
        }

        function isMersennePrime(n) {
            return mersennePrimes.includes(n);
        }

        function isTwinPrime(n) {
            return (isPrime(n + 2) || isPrime(n - 2));
        }

        function isCousinPrime(n) {
            return (isPrime(n + 4) || isPrime(n - 4));
        }

        function isSexyPrime(n) {
            return (isPrime(n + 6) || isPrime(n - 6));
        }

        // Ramanujan primes: computed on demand, cached
        let ramanujanCache = null;
        function getRamanujanPrimes(limit) {
            if (ramanujanCache) return ramanujanCache;
            // Ramanujan prime R_n is the least integer such that π(x) - π(x/2) ≥ n for all x ≥ R_n
            // For practical purposes, use known Ramanujan primes up to limit
            const known = [2, 11, 13, 29, 37, 41, 47, 59, 67, 71, 79, 97, 101, 107, 127, 149, 163, 181, 191, 197, 223, 229, 233, 239, 241, 251, 257, 263, 269, 281, 307, 311, 317, 337, 347, 349, 353, 359, 367, 373, 389, 397, 401, 409, 419, 431, 439, 443, 449, 457, 461, 467, 479];
            ramanujanCache = known.filter(p => p <= limit);
            return ramanujanCache;
        }

        function isRamanujanPrime(n) {
            return getRamanujanPrimes(n + 1000).includes(n);
        }

        // Fermat primes: 2^(2^k)+1. Only 5 known
        function isFermatPrime(n) {
            for (let k = 0; k < 5; k++) {
                const exp = Math.pow(2, k);
                if (exp > 100000) break; // Fermat numbers get huge quickly
                const fermat = Math.pow(2, exp) + 1;
                if (fermat === n) return true;
                if (fermat > n) break;
            }
            return false;
        }

        // Mersenne primes: 2^p-1 where p is prime. Generate up to limit
        let mersenneCache = null;
        function getMersennePrimes(limit) {
            if (mersenneCache) return mersenneCache;
            const result = [];
            for (let exp = 2; Math.pow(2, exp) - 1 <= limit; exp++) {
                if (isPrime(exp)) {
                    const mersenne = Math.pow(2, exp) - 1;
                    // Check if the mersenne number itself is prime (expensive for large exponents)
                    if (mersenne <= 524287) { // Known Mersenne primes up to this
                        if (isPrime(mersenne)) {
                            result.push(mersenne);
                        }
                    }
                }
            }
            mersenneCache = result;
            return result;
        }

        function isMersennePrime(n) {
            return getMersennePrimes(n + 1000).includes(n);
        }

        // Sophie Germain primes: p where 2p+1 is also prime
        function isSophieGermainPrime(n) {
            if (!isPrime(n)) return false;
            return isPrime(2 * n + 1);
        }

        // Safe primes: prime p where (p-1)/2 is also prime
        function isSafePrime(n) {
            if (!isPrime(n) || n === 2) return false;
            return isPrime((n - 1) / 2);
        }

        // Palindromic primes: prime that reads the same forwards and backwards
        function isPalindromicPrime(n) {
            if (!isPrime(n)) return false;
            const str = n.toString();
            return str === str.split('').reverse().join('');
        }

        // Prime triplets: (p, p+2, p+6) or (p, p+4, p+6) all prime
        function isPrimeTriplet(n) {
            if (!isPrime(n)) return false;
            // Check (p, p+2, p+6)
            if (isPrime(n + 2) && isPrime(n + 6)) return true;
            // Check (p, p+4, p+6)
            if (isPrime(n + 4) && isPrime(n + 6)) return true;
            return false;
        }

        // Prime quadruplets: (p, p+2, p+6, p+8) all prime
        function isPrimeQuadruplet(n) {
            if (!isPrime(n)) return false;
            return isPrime(n + 2) && isPrime(n + 6) && isPrime(n + 8);
        }

        // Chen primes: prime p where p+2 is either prime or semiprime (product of exactly 2 primes)
        function isChPrime(n) {
            if (!isPrime(n)) return false;
            const p2 = n + 2;
            if (isPrime(p2)) return true;
            // Check if semiprime: find smallest factor and see if quotient is prime
            for (let i = 2; i * i <= p2; i++) {
                if (p2 % i === 0) {
                    const quotient = p2 / i;
                    return isPrime(quotient);
                }
            }
            return false;
        }

        // Pythagorean primes: primes of form 4k+1
        function isPythagoreanPrime(n) {
            if (!isPrime(n)) return false;
            return n % 4 === 1;
        }

        // Circular primes: all cyclic rotations of digits are prime
        function isCircularPrime(n) {
            if (!isPrime(n)) return false;
            const str = n.toString();
            if (str.length === 1) return true;
            for (let i = 1; i < str.length; i++) {
                const rotated = str.substring(i) + str.substring(0, i);
                if (!isPrime(parseInt(rotated))) return false;
            }
            return true;
        }

        function getPrimeTypes(n) {
            // Early exit if no special types are active
            if (activePrimeTypes.size === 0) return [];

            const types = [];
            // Only check types that are actually selected
            if (activePrimeTypes.has('ramanujan') && isRamanujanPrime(n)) types.push('ramanujan');
            if (activePrimeTypes.has('fermat') && isFermatPrime(n)) types.push('fermat');
            if (activePrimeTypes.has('mersenne') && isMersennePrime(n)) types.push('mersenne');
            if (activePrimeTypes.has('twin') && isTwinPrime(n)) types.push('twin');
            if (activePrimeTypes.has('cousin') && isCousinPrime(n)) types.push('cousin');
            if (activePrimeTypes.has('sexy') && isSexyPrime(n)) types.push('sexy');
            if (activePrimeTypes.has('sophie') && isSophieGermainPrime(n)) types.push('sophie');
            if (activePrimeTypes.has('safe') && isSafePrime(n)) types.push('safe');
            if (activePrimeTypes.has('palindromic') && isPalindromicPrime(n)) types.push('palindromic');
            if (activePrimeTypes.has('triplet') && isPrimeTriplet(n)) types.push('triplet');
            if (activePrimeTypes.has('quadruplet') && isPrimeQuadruplet(n)) types.push('quadruplet');
            if (activePrimeTypes.has('chen') && isChPrime(n)) types.push('chen');
            if (activePrimeTypes.has('pythagorean') && isPythagoreanPrime(n)) types.push('pythagorean');
            if (activePrimeTypes.has('circular') && isCircularPrime(n)) types.push('circular');
            return types;
        }

        function getPrimeColor(n) {
            const matchingTypes = getPrimeTypes(n).filter(type => activePrimeTypes.has(type));

            // No active types match - show black
            if (matchingTypes.length === 0) {
                return 'rgba(0, 0, 0, 1)';
            }

            // One type matches - show its color
            if (matchingTypes.length === 1) {
                return primeTypeColors[matchingTypes[0]];
            }

            // Multiple types match - use flash animation
            const colorIndex = Math.floor(flashFrameCount / 10) % matchingTypes.length;
            return primeTypeColors[matchingTypes[colorIndex]];
        }

        function primeFactorization(n) {
            if (n <= 1) return [];
            const factors = [];
            while (n % 2 === 0) {
                factors.push(2);
                n /= 2;
            }
            while (n % 3 === 0) {
                factors.push(3);
                n /= 3;
            }
            let divisor = 5;
            while (divisor * divisor <= n) {
                while (n % divisor === 0) {
                    factors.push(divisor);
                    n /= divisor;
                }
                while (n % (divisor + 2) === 0) {
                    factors.push(divisor + 2);
                    n /= (divisor + 2);
                }
                divisor += 6;
            }
            if (n > 1) factors.push(n);
            return factors;
        }

        function isPrime(n) {
            return primality(n);
        }

        function generatePseudoprimorialNumbers(count) {
            const expected = [1, 2, 4, 6, 12, 18, 24, 30, 60, 90, 120, 150, 180, 210, 420, 630, 840, 1050, 1260, 1470, 1680, 1890, 2100, 2310, 4620];
            if (count <= expected.length) return expected.slice(0, count);
            const result = [...expected];
            let last = expected[expected.length - 1];
            while (result.length < count) {
                last += 4620;
                result.push(last);
            }
            return result.slice(0, count);
        }

        function generateColorFromFactors(num) {
            const colorFunction = compositeColorFunctions[currentCompositeColorScheme];
            return colorFunction(num);
        }

        // Cache for pseudoprimorials to avoid recalculating
        let pseudoprimorialCache = [];

        function getPseudoprimorial(row) {
            while (pseudoprimorialCache.length <= row) {
                const nextIdx = pseudoprimorialCache.length;
                const psuedos = generatePseudoprimorialNumbers(nextIdx + 100);
                pseudoprimorialCache = psuedos;
            }
            return pseudoprimorialCache[row];
        }

        // Check if a cell should be greyed out based on pseudoprimorial midpoints
        function shouldGreyOut(row, col) {
            const pseudoprimorial = getPseudoprimorial(row);
            const value = pseudoprimorial + col;

            // Check midpoint with next row
            if (row + 1 < pseudoprimorialCache.length) {
                const nextPseudoprimorial = getPseudoprimorial(row + 1);
                const midpointNext = (pseudoprimorial + nextPseudoprimorial) / 2;
                if (value > midpointNext) return true;
            }

            // Check midpoint with previous row
            if (row > 1) {
                const prevPseudoprimorial = getPseudoprimorial(row - 1);
                const midpointPrev = (prevPseudoprimorial + pseudoprimorial) / 2;
                if (value < midpointPrev) return true;
            }

            return false;
        }

        // Apply greyed out effect to a color
        function greyOutColor(color) {
            // Reduce opacity and desaturate slightly
            if (color.includes('rgba')) {
                // Parse rgba and reduce opacity
                const match = color.match(/rgba\((\d+),\s*(\d+),\s*(\d+),\s*([0-9.]+)\)/);
                if (match) {
                    const r = match[1];
                    const g = match[2];
                    const b = match[3];
                    const alpha = parseFloat(match[4]);
                    // Reduce opacity by half and add grey wash
                    const newAlpha = alpha * 0.4;
                    return `rgba(${r}, ${g}, ${b}, ${newAlpha})`;
                }
            }
            return color;
        }

        // Render only visible cells
        function renderVisibleCells() {
            grid.innerHTML = '';

            const { minCol, maxCol, minRow, maxRow } = getVisibleGridBounds();

            for (let row = minRow; row < maxRow; row++) {
                for (let col = minCol; col < maxCol; col++) {
                    const pseudoprimorial = getPseudoprimorial(row);
                    const value = pseudoprimorial + col;

                    const cell = document.createElement('div');
                    cell.className = 'cell';

                    // Position cell absolutely based on grid coordinates
                    // Row 1 is at top (y=0), row 2 at y=cellHeight, etc.
                    cell.style.left = (col * cellWidth) + 'px';
                    cell.style.top = ((row - 1) * cellHeight) + 'px';
                    cell.style.width = cellWidth + 'px';
                    cell.style.height = cellHeight + 'px';

                    // Set color
                    let bgColor;
                    if (value <= 0) {
                        bgColor = 'rgba(255, 255, 255, 0.3)';
                    } else if (isPrime(value)) {
                        bgColor = getPrimeColor(value);
                    } else {
                        bgColor = generateColorFromFactors(value);
                    }

                    // Apply grey-out if in invalid zone
                    if (shouldGreyOut(row, col)) {
                        bgColor = greyOutColor(bgColor);
                        cell.style.border = '1px solid black';
                    }

                    cell.style.backgroundColor = bgColor;

                    // Store data for event delegation hover
                    cell.dataset.row = row;
                    cell.dataset.col = col;
                    cell.dataset.value = value;
                    cell.dataset.pseudoprimorial = pseudoprimorial;

                    grid.appendChild(cell);
                }
            }
        }

        // Event delegation for cell hover
        grid.addEventListener('mouseover', (e) => {
            const cell = e.target.closest('.cell');
            if (cell && cell.dataset.value) {
                const row = parseInt(cell.dataset.row);
                const col = parseInt(cell.dataset.col);
                const value = parseInt(cell.dataset.value);
                const pseudoprimorial = parseInt(cell.dataset.pseudoprimorial);
                const factors = primeFactorization(Math.abs(value));
                const factorStr = factors.length > 0 ? factors.join(' × ') : '1';
                coordinatesDisplay.innerHTML = `Row: ${row} | Column: ${col} | Value: ${value}, Factors: ${factorStr} | Row Center: ${pseudoprimorial}`;
            }
        });

        // Radio button event listeners for composite colors
        const compositeRadios = document.querySelectorAll('input[name="composite"]');
        compositeRadios.forEach(radio => {
            radio.addEventListener('change', () => {
                if (radio.checked) {
                    currentCompositeColorScheme = radio.value;
                    renderVisibleCells();
                }
            });
        });

        // Animation loop for flashing primes - only runs when special primes are active
        function animationLoop() {
            if (activePrimeTypes.size > 0) {
                flashFrameCount++;
                // Only re-render every 10 frames for color cycling (reduces from 60fps to 6fps)
                if (flashFrameCount % 10 === 0) {
                    renderVisibleCells();
                }
                animationFrameId = requestAnimationFrame(animationLoop);
            }
        }

        // Start animation loop when special primes are checked
        const primeCheckboxes = document.querySelectorAll('input[type="checkbox"][id^="prime-"]');
        primeCheckboxes.forEach(checkbox => {
            checkbox.addEventListener('change', () => {
                if (checkbox.checked) {
                    activePrimeTypes.add(checkbox.value);
                } else {
                    activePrimeTypes.delete(checkbox.value);
                }
                renderVisibleCells();
                // Start animation loop if this was the first type checked
                if (activePrimeTypes.size === 1) {
                    animationLoop();
                }
            });
        });

        // Initial setup
        calculateCellDimensions();
        offsetX = viewport.clientWidth / 2;  // Center column 0
        offsetY = 0;
        zoomLevel = 1;

        // Set the correct radio button for the default composite color scheme
        const radioForDefault = document.querySelector(`input[name="composite"][value="${currentCompositeColorScheme}"]`);
        if (radioForDefault) {
            radioForDefault.checked = true;
        }

        renderVisibleCells();
        // Animation loop starts only when special primes are checked
    </script>
</body>
</html>
